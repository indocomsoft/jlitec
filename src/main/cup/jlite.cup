package jlitec;

import java_cup.runtime.*;

// Keywords
terminal CLASS, MAIN, IF, ELSE, WHILE, READLN, PRINTLN, RETURN, THIS, NEW, NULL;
// Types
terminal INT, BOOL, STRING, VOID;
// Punctuations
terminal LBRACE, RBRACE, LPAREN, RPAREN, SEMICOLON, COMMA, DOT;
// Operators
terminal ASSIGN, OR, AND, GT, LT, GEQ, LEQ, EQ, NEQ, NOT, PLUS, MINUS, MULT, DIV;
// Booleans
terminal TRUE, FALSE;

terminal String ID;
terminal String CNAME;
terminal Integer INTEGER_LITERAL;
terminal String STRING_LITERAL;

non terminal Program;
non terminal MainClass;
non terminal ClassDecl, ClassDecl_star;
non terminal FmlList;
non terminal MdBody;
non terminal VarDecl, VarDecl_plus, VarDecl_star;
non terminal MdDecl, MdDecl_plus;
non terminal Type;
non terminal FmlRest, FmlRest_star;
non terminal Stmt, Stmt_plus, Stmt_star;
non terminal Exp;
non terminal Atom;
non terminal ExpList;
non terminal BExp;
non terminal AExp;
non terminal SExp, S;
non terminal RExp;
non terminal Conj;
non terminal BOp;
non terminal BGrd;
non terminal Term;
non terminal Ftr;
non terminal ExpRest, ExpRest_star;
non terminal ClassBody;

start with Program;

Program ::= MainClass ClassDecl_star ;

MainClass ::= CLASS CNAME LBRACE VOID MAIN LPAREN FmlList RPAREN MdBody RBRACE ;

ClassDecl ::= CLASS CNAME LBRACE ClassBody RBRACE ;
ClassDecl_star ::= ClassDecl_star ClassDecl | ;

ClassBody ::= VarDecl_plus MdDecl_plus | VarDecl_plus | MdDecl_plus | ;

VarDecl ::= Type ID SEMICOLON ;
VarDecl_plus ::= VarDecl_plus VarDecl | VarDecl;
VarDecl_star ::= VarDecl_plus | ;

MdDecl ::= Type ID LPAREN FmlList RPAREN MdBody ;
MdDecl_plus ::= MdDecl_plus MdDecl | MdDecl;

FmlList ::= Type ID FmlRest_star | ;

FmlRest ::= COMMA Type ID ;
FmlRest_star ::= FmlRest_star FmlRest | ;

Type ::= INT | BOOL | STRING | VOID | CNAME ;

MdBody ::= LBRACE VarDecl_star Stmt_plus RBRACE ;

Stmt ::= IF LPAREN Exp RPAREN LBRACE Stmt_plus RBRACE ELSE LBRACE Stmt_plus RBRACE
       | WHILE LPAREN Exp RPAREN LBRACE Stmt_star RBRACE
       | READLN LPAREN ID RPAREN SEMICOLON
       | PRINTLN LPAREN Exp RPAREN SEMICOLON
       | ID ASSIGN Exp SEMICOLON
       | Atom DOT ID ASSIGN Exp SEMICOLON
       | Atom LPAREN ExpList RPAREN SEMICOLON
       | RETURN Exp SEMICOLON
       | RETURN SEMICOLON
       ;
Stmt_plus ::= Stmt Stmt_star;
Stmt_star ::= Stmt_star Stmt | ;

// Exp ::= BExp | AExp | SExp ;

Exp ::=
// unknown
        Atom
// Boolean
      // BExp
      | BExp OR Conj
      // Conj
      | Conj AND RExp
      // RExp
      | AExp BOp AExp
      // BGrd
      NOT BGrd
      | TRUE
      | FALSE
// Integer
      // AExp
      | AExp PLUS Term
      | AExp MINUS Term
      // Term
      | Term MULT Ftr
      | Term DIV Ftr
      // Ftr
      | INTEGER_LITERAL
      | MINUS Ftr
// String
      // SExp
      | STRING_LITERAL PLUS SExp // TODO! how to resolve otherwise?
      // S
      | STRING_LITERAL
      ;

BExp ::= BExp OR Conj | Conj ;

Conj ::= Conj AND RExp | RExp ;

RExp ::= AExp BOp AExp | BGrd ;

BOp ::= LT | GT | LEQ | GEQ | EQ | NEQ ;

BGrd ::= NOT BGrd | TRUE | FALSE | Atom ;

AExp ::= AExp PLUS Term | AExp MINUS Term | Term ;

Term ::= Term MULT Ftr | Term DIV Ftr | Ftr ;

Ftr ::= INTEGER_LITERAL | MINUS Ftr | Atom ;

SExp ::= SExp PLUS S | S ;
S ::= STRING_LITERAL | Atom ;

Atom ::= Atom DOT ID
       | Atom LPAREN ExpList RPAREN
       | THIS
       | ID
       | NEW CNAME LPAREN RPAREN
       | LPAREN Exp RPAREN
       | NULL
       ;

ExpList ::= Exp ExpRest_star | ;

ExpRest ::= COMMA Exp ;
ExpRest_star ::= ExpRest_star ExpRest | ;
